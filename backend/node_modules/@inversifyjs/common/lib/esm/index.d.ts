declare function isPromise<T>(object: unknown): object is Promise<T>;

type Either<TLeft, TRight> = Left<TLeft> | Right<TRight>;
interface BaseEither<T> {
    value: T;
}
interface Left<T> extends BaseEither<T> {
    isRight: false;
}
interface Right<T> extends BaseEither<T> {
    isRight: true;
}

type AbstractNewable<TInstance = unknown, TArgs extends unknown[] = any[]> = abstract new (...args: TArgs) => TInstance;

type Newable<TInstance = unknown, TArgs extends unknown[] = any[]> = new (...args: TArgs) => TInstance;

type ServiceIdentifier<TInstance = unknown> = string | symbol | Newable<TInstance> | AbstractNewable<TInstance> | Function;

declare function stringifyServiceIdentifier(serviceIdentifier: ServiceIdentifier): string;

declare const islazyServiceIdentifierSymbol: unique symbol;
declare class LazyServiceIdentifier<TInstance = unknown> {
    #private;
    [islazyServiceIdentifierSymbol]: true;
    constructor(buildServiceId: () => ServiceIdentifier<TInstance>);
    static is<TInstance = unknown>(value: unknown): value is LazyServiceIdentifier<TInstance>;
    unwrap(): ServiceIdentifier<TInstance>;
}

export { LazyServiceIdentifier, isPromise, stringifyServiceIdentifier };
export type { AbstractNewable, BaseEither, Either, Left, Newable, Right, ServiceIdentifier };
