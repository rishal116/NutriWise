import { Newable, ServiceIdentifier } from '@inversifyjs/common';
import { Binding, BindingActivation, BindingConstraints, BindingDeactivation, BindingScope, BindingType, DynamicValueBuilder, Factory, MetadataName, MetadataTag, Provider, ResolutionContext, ScopedBinding } from '@inversifyjs/core';
import { Writable } from '../../common/models/Writable';
import { BindInFluentSyntax, BindInWhenOnFluentSyntax, BindOnFluentSyntax, BindToFluentSyntax, BindWhenFluentSyntax, BindWhenOnFluentSyntax } from './BindingFluentSyntax';
import { BindingIdentifier } from './BindingIdentifier';
import { MapToResolvedValueInjectOptions } from './MapToResolvedValueInjectOptions';
export declare class BindInFluentSyntaxImplementation<T> implements BindInFluentSyntax<T> {
    #private;
    constructor(binding: Writable<ScopedBinding<BindingType, BindingScope, T>>);
    getIdentifier(): BindingIdentifier;
    inRequestScope(): BindWhenOnFluentSyntax<T>;
    inSingletonScope(): BindWhenOnFluentSyntax<T>;
    inTransientScope(): BindWhenOnFluentSyntax<T>;
}
export declare class BindToFluentSyntaxImplementation<T> implements BindToFluentSyntax<T> {
    #private;
    constructor(callback: (binding: Binding<T>) => void, containerModuleId: number | undefined, defaultScope: BindingScope, serviceIdentifier: ServiceIdentifier<T>);
    to(type: Newable<T>): BindInWhenOnFluentSyntax<T>;
    toSelf(): BindInWhenOnFluentSyntax<T>;
    toConstantValue(value: T): BindWhenOnFluentSyntax<T>;
    toDynamicValue(builder: DynamicValueBuilder<T>): BindInWhenOnFluentSyntax<T>;
    toResolvedValue(factory: () => T | Promise<T>): BindInWhenOnFluentSyntax<T>;
    toResolvedValue<TArgs extends unknown[]>(factory: (...args: TArgs) => T | Promise<T>, injectOptions: MapToResolvedValueInjectOptions<TArgs>): BindInWhenOnFluentSyntax<T>;
    toFactory<T extends Factory<unknown, any>>(this: BindToFluentSyntaxImplementation<T>, builder: (context: ResolutionContext) => T | Promise<T>): BindWhenOnFluentSyntax<T>;
    /**
     * @deprecated Use `toFactory()` instead. Providers will be removed in v8.
     * Providers exist for historical reasons from v5 when async dependencies weren't supported.
     * Factories are more flexible and can handle both sync and async operations.
     */
    toProvider<T extends Provider<unknown, any>>(this: BindToFluentSyntaxImplementation<T>, provider: (context: ResolutionContext) => T): BindWhenOnFluentSyntax<T>;
    toService(service: ServiceIdentifier<T>): void;
}
export declare class BindOnFluentSyntaxImplementation<T> implements BindOnFluentSyntax<T> {
    #private;
    constructor(binding: Writable<ScopedBinding<BindingType, BindingScope, T>>);
    getIdentifier(): BindingIdentifier;
    onActivation(activation: BindingActivation<T>): BindWhenFluentSyntax<T>;
    onDeactivation(deactivation: BindingDeactivation<T>): BindWhenFluentSyntax<T>;
}
export declare class BindWhenFluentSyntaxImplementation<T> implements BindWhenFluentSyntax<T> {
    #private;
    constructor(binding: Writable<ScopedBinding<BindingType, BindingScope, T>>);
    getIdentifier(): BindingIdentifier;
    when(constraint: (metadata: BindingConstraints) => boolean): BindOnFluentSyntax<T>;
    whenAnyAncestor(constraint: (metadata: BindingConstraints) => boolean): BindOnFluentSyntax<T>;
    whenAnyAncestorIs(serviceIdentifier: ServiceIdentifier): BindOnFluentSyntax<T>;
    whenAnyAncestorNamed(name: MetadataName): BindOnFluentSyntax<T>;
    whenAnyAncestorTagged(tag: MetadataTag, tagValue: unknown): BindOnFluentSyntax<T>;
    whenDefault(): BindOnFluentSyntax<T>;
    whenNamed(name: MetadataName): BindOnFluentSyntax<T>;
    whenNoParent(constraint: (metadata: BindingConstraints) => boolean): BindOnFluentSyntax<T>;
    whenNoParentIs(serviceIdentifier: ServiceIdentifier): BindOnFluentSyntax<T>;
    whenNoParentNamed(name: MetadataName): BindOnFluentSyntax<T>;
    whenNoParentTagged(tag: MetadataTag, tagValue: unknown): BindOnFluentSyntax<T>;
    whenParent(constraint: (metadata: BindingConstraints) => boolean): BindOnFluentSyntax<T>;
    whenParentIs(serviceIdentifier: ServiceIdentifier): BindOnFluentSyntax<T>;
    whenParentNamed(name: MetadataName): BindOnFluentSyntax<T>;
    whenParentTagged(tag: MetadataTag, tagValue: unknown): BindOnFluentSyntax<T>;
    whenTagged(tag: MetadataTag, tagValue: unknown): BindOnFluentSyntax<T>;
    whenNoAncestor(constraint: (metadata: BindingConstraints) => boolean): BindOnFluentSyntax<T>;
    whenNoAncestorIs(serviceIdentifier: ServiceIdentifier): BindOnFluentSyntax<T>;
    whenNoAncestorNamed(name: MetadataName): BindOnFluentSyntax<T>;
    whenNoAncestorTagged(tag: MetadataTag, tagValue: unknown): BindOnFluentSyntax<T>;
}
export declare class BindWhenOnFluentSyntaxImplementation<T> extends BindWhenFluentSyntaxImplementation<T> implements BindWhenOnFluentSyntax<T> {
    #private;
    constructor(binding: Writable<ScopedBinding<BindingType, BindingScope, T>>);
    onActivation(activation: BindingActivation<T>): BindWhenFluentSyntax<T>;
    onDeactivation(deactivation: BindingDeactivation<T>): BindWhenFluentSyntax<T>;
}
export declare class BindInWhenOnFluentSyntaxImplementation<T> extends BindWhenOnFluentSyntaxImplementation<T> implements BindInWhenOnFluentSyntax<T> {
    #private;
    constructor(binding: Writable<ScopedBinding<BindingType, BindingScope, T>>);
    inRequestScope(): BindWhenOnFluentSyntax<T>;
    inSingletonScope(): BindWhenOnFluentSyntax<T>;
    inTransientScope(): BindWhenOnFluentSyntax<T>;
}
//# sourceMappingURL=BindingFluentSyntaxImplementation.d.ts.map