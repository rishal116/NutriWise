import{getOwnReflectMetadata as e,setReflectMetadata as t,updateOwnReflectMetadata as n}from"@inversifyjs/reflect-metadata-utils";import{getBaseType as i}from"@inversifyjs/prototype-utils";import{stringifyServiceIdentifier as o,LazyServiceIdentifier as r,isPromise as s}from"@inversifyjs/common";const a="@inversifyjs/container/bindingId";function c(){const i=e(Object,a)??0;return i===Number.MAX_SAFE_INTEGER?t(Object,a,Number.MIN_SAFE_INTEGER):n(Object,a,()=>i,e=>e+1),i}const d={Request:"Request",Singleton:"Singleton",Transient:"Transient"},u={ConstantValue:"ConstantValue",DynamicValue:"DynamicValue",Factory:"Factory",Instance:"Instance",Provider:"Provider",ResolvedValue:"ResolvedValue",ServiceRedirection:"ServiceRedirection"};function*l(...e){for(const t of e)yield*t}class p{#e;#t;#n;constructor(e){this.#e=new Map,this.#t={};for(const t of Reflect.ownKeys(e))this.#t[t]=new Map;this.#n=e}add(e,t){this.#i(e).push(t);for(const n of Reflect.ownKeys(t))this.#o(n,t[n]).push(e)}clone(){const e=this.#r(),t=this.#s(),n=Reflect.ownKeys(this.#n),i=this._buildNewInstance(this.#n);this.#a(this.#e,i.#e,e,t);for(const t of n)this.#c(this.#t[t],i.#t[t],e);return i}get(e,t){return this.#t[e].get(t)}getAllKeys(e){return this.#t[e].keys()}removeByRelation(e,t){const n=this.get(e,t);if(void 0===n)return;const i=new Set(n);for(const n of i){const i=this.#e.get(n);if(void 0===i)throw new Error("Expecting model relation, none found");for(const o of i)o[e]===t&&this.#d(n,o);this.#e.delete(n)}}_buildNewInstance(e){return new p(e)}_cloneModel(e){return e}_cloneRelation(e){return e}#r(){const e=new Map;for(const t of this.#e.keys()){const n=this._cloneModel(t);e.set(t,n)}return e}#s(){const e=new Map;for(const t of this.#e.values())for(const n of t){const t=this._cloneRelation(n);e.set(n,t)}return e}#i(e){let t=this.#e.get(e);return void 0===t&&(t=[],this.#e.set(e,t)),t}#o(e,t){let n=this.#t[e].get(t);return void 0===n&&(n=[],this.#t[e].set(t,n)),n}#u(e,t){const n=t.get(e);if(void 0===n)throw new Error("Expecting model to be cloned, none found");return n}#l(e,t){const n=t.get(e);if(void 0===n)throw new Error("Expecting relation to be cloned, none found");return n}#c(e,t,n){for(const[i,o]of e){const e=new Array;for(const t of o)e.push(this.#u(t,n));t.set(i,e)}}#a(e,t,n,i){for(const[o,r]of e){const e=new Array;for(const t of r)e.push(this.#l(t,i));t.set(this.#u(o,n),e)}}#d(e,t){for(const n of Reflect.ownKeys(t))this.#p(e,n,t[n])}#p(e,t,n){const i=this.#t[t].get(n);if(void 0!==i){const o=i.indexOf(e);-1!==o&&i.splice(o,1),0===i.length&&this.#t[t].delete(n)}}}var f;!function(e){e.moduleId="moduleId",e.serviceId="serviceId"}(f||(f={}));class v{#f;#v;constructor(e,t){this.#f=t??new p({moduleId:{isOptional:!0},serviceId:{isOptional:!1}}),this.#v=e}static build(e){return new v(e)}add(e,t){this.#f.add(e,t)}clone(){return new v(this.#v,this.#f.clone())}get(e){const t=[],n=this.#f.get(f.serviceId,e);void 0!==n&&t.push(n);const i=this.#v()?.get(e);if(void 0!==i&&t.push(i),0!==t.length)return l(...t)}removeAllByModuleId(e){this.#f.removeByRelation(f.moduleId,e)}removeAllByServiceId(e){this.#f.removeByRelation(f.serviceId,e)}}const h="@inversifyjs/core/classMetadataReflectKey";function g(){return{constructorArguments:[],lifecycle:{postConstructMethodNames:new Set,preDestroyMethodNames:new Set},properties:new Map,scope:void 0}}const m="@inversifyjs/core/pendingClassMetadataCountReflectKey";const y=Symbol.for("@inversifyjs/core/InversifyCoreError");class M extends Error{[y];kind;constructor(e,t,n){super(t,n),this[y]=!0,this.kind=e}static is(e){return"object"==typeof e&&null!==e&&!0===e[y]}static isErrorOfKind(e,t){return M.is(e)&&e.kind===t}}var I,b,w,C,S;function N(t){const n=e(t,h)??g();if(!function(t){const n=e(t,m);return void 0!==n&&0!==n}(t))return function(e,t){const n=[];if(t.length<e.length)throw new M(I.missingInjectionDecorator,`Found unexpected missing metadata on type "${e.name}". "${e.name}" constructor requires at least ${e.length.toString()} arguments, found ${t.length.toString()} instead.\nAre you using @inject, @multiInject or @unmanaged decorators in every non optional constructor argument?\n\nIf you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);for(let e=0;e<t.length;++e)void 0===t[e]&&n.push(e);if(n.length>0)throw new M(I.missingInjectionDecorator,`Found unexpected missing metadata on type "${e.name}" at constructor indexes "${n.join('", "')}".\n\nAre you using @inject, @multiInject or @unmanaged decorators at those indexes?\n\nIf you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`)}(t,n.constructorArguments),n;!function(e,t){const n=[];for(let i=0;i<t.constructorArguments.length;++i){const o=t.constructorArguments[i];void 0!==o&&o.kind!==b.unknown||n.push(`  - Missing or incomplete metadata for type "${e.name}" at constructor argument with index ${i.toString()}.\nEvery constructor parameter must be decorated either with @inject, @multiInject or @unmanaged decorator.`)}for(const[i,o]of t.properties)o.kind===b.unknown&&n.push(`  - Missing or incomplete metadata for type "${e.name}" at property "${i.toString()}".\nThis property must be decorated either with @inject or @multiInject decorator.`);if(0===n.length)throw new M(I.unknown,`Unexpected class metadata for type "${e.name}" with uncompletion traces.\nThis might be caused by one of the following reasons:\n\n1. A third party library is targeting inversify reflection metadata.\n2. A bug is causing the issue. Consider submiting an issue to fix it.`);throw new M(I.missingInjectionDecorator,`Invalid class metadata at type ${e.name}:\n\n${n.join("\n\n")}`)}(t,n)}function P(e,t){const n=N(t).scope??e.scope;return{cache:{isRight:!1,value:void 0},id:c(),implementationType:t,isSatisfiedBy:()=>!0,moduleId:void 0,onActivation:void 0,onDeactivation:void 0,scope:n,serviceIdentifier:t,type:u.Instance}}function A(e){return e.isRight?{isRight:!0,value:e.value}:e}function R(e){switch(e.type){case u.ConstantValue:case u.DynamicValue:return function(e){return{cache:A(e.cache),id:e.id,isSatisfiedBy:e.isSatisfiedBy,moduleId:e.moduleId,onActivation:e.onActivation,onDeactivation:e.onDeactivation,scope:e.scope,serviceIdentifier:e.serviceIdentifier,type:e.type,value:e.value}}(e);case u.Factory:return function(e){return{cache:A(e.cache),factory:e.factory,id:e.id,isSatisfiedBy:e.isSatisfiedBy,moduleId:e.moduleId,onActivation:e.onActivation,onDeactivation:e.onDeactivation,scope:e.scope,serviceIdentifier:e.serviceIdentifier,type:e.type}}(e);case u.Instance:return function(e){return{cache:A(e.cache),id:e.id,implementationType:e.implementationType,isSatisfiedBy:e.isSatisfiedBy,moduleId:e.moduleId,onActivation:e.onActivation,onDeactivation:e.onDeactivation,scope:e.scope,serviceIdentifier:e.serviceIdentifier,type:e.type}}(e);case u.Provider:return function(e){return{cache:A(e.cache),id:e.id,isSatisfiedBy:e.isSatisfiedBy,moduleId:e.moduleId,onActivation:e.onActivation,onDeactivation:e.onDeactivation,provider:e.provider,scope:e.scope,serviceIdentifier:e.serviceIdentifier,type:e.type}}(e);case u.ResolvedValue:return function(e){return{cache:A(e.cache),factory:e.factory,id:e.id,isSatisfiedBy:e.isSatisfiedBy,metadata:e.metadata,moduleId:e.moduleId,onActivation:e.onActivation,onDeactivation:e.onDeactivation,scope:e.scope,serviceIdentifier:e.serviceIdentifier,type:e.type}}(e);case u.ServiceRedirection:return function(e){return{id:e.id,isSatisfiedBy:e.isSatisfiedBy,moduleId:e.moduleId,serviceIdentifier:e.serviceIdentifier,targetServiceIdentifier:e.targetServiceIdentifier,type:e.type}}(e)}}!function(e){e[e.injectionDecoratorConflict=0]="injectionDecoratorConflict",e[e.missingInjectionDecorator=1]="missingInjectionDecorator",e[e.planning=2]="planning",e[e.resolution=3]="resolution",e[e.unknown=4]="unknown"}(I||(I={})),function(e){e[e.unknown=32]="unknown"}(b||(b={})),function(e){e.id="id",e.moduleId="moduleId",e.serviceId="serviceId"}(w||(w={}));class x extends p{_buildNewInstance(e){return new x(e)}_cloneModel(e){return R(e)}}class T{#h;#g;#v;constructor(e,t,n){this.#g=n??new x({id:{isOptional:!1},moduleId:{isOptional:!0},serviceId:{isOptional:!1}}),this.#v=e,this.#h=t}static build(e,t){return new T(e,t)}clone(){return new T(this.#v,this.#h,this.#g.clone())}get(e){const t=this.getNonParentBindings(e)??this.#v()?.get(e);if(void 0!==t)return t;const n=this.#m(e);return void 0===n?n:[n]}*getChained(e){const t=this.getNonParentBindings(e);void 0!==t&&(yield*t);const n=this.#v();if(void 0===n){if(void 0===t){const t=this.#m(e);void 0!==t&&(yield t)}}else yield*n.getChained(e)}getBoundServices(){const e=new Set(this.#g.getAllKeys(w.serviceId)),t=this.#v();if(void 0!==t)for(const n of t.getBoundServices())e.add(n);return e}getById(e){return this.#g.get(w.id,e)??this.#v()?.getById(e)}getByModuleId(e){return this.#g.get(w.moduleId,e)??this.#v()?.getByModuleId(e)}getNonParentBindings(e){return this.#g.get(w.serviceId,e)}getNonParentBoundServices(){return this.#g.getAllKeys(w.serviceId)}removeById(e){this.#g.removeByRelation(w.id,e)}removeAllByModuleId(e){this.#g.removeByRelation(w.moduleId,e)}removeAllByServiceId(e){this.#g.removeByRelation(w.serviceId,e)}set(e){const t={[w.id]:e.id,[w.serviceId]:e.serviceIdentifier};void 0!==e.moduleId&&(t[w.moduleId]=e.moduleId),this.#g.add(e,t)}#m(e){if(void 0===this.#h||"function"!=typeof e)return;const t=P(this.#h,e);return this.set(t),t}}!function(e){e.moduleId="moduleId",e.serviceId="serviceId"}(C||(C={}));class j{#y;#v;constructor(e,t){this.#y=t??new p({moduleId:{isOptional:!0},serviceId:{isOptional:!1}}),this.#v=e}static build(e){return new j(e)}add(e,t){this.#y.add(e,t)}clone(){return new j(this.#v,this.#y.clone())}get(e){const t=[],n=this.#y.get(C.serviceId,e);void 0!==n&&t.push(n);const i=this.#v()?.get(e);if(void 0!==i&&t.push(i),0!==t.length)return l(...t)}removeAllByModuleId(e){this.#y.removeByRelation(C.moduleId,e)}removeAllByServiceId(e){this.#y.removeByRelation(C.serviceId,e)}}function B(e,t,n,i){const o=Array.isArray(e)?e:[e];if(void 0!==n)if("number"!=typeof n)if(void 0!==i)for(const e of o)e(t,n,i);else Reflect.decorate(o,t.prototype,n);else for(const e of o)e(t,void 0,n);else Reflect.decorate(o,t)}function F(){return 0}function k(e){return t=>{void 0!==t&&t.kind===b.unknown&&n(e,m,F,e=>e-1)}}function $(e,t){return(...n)=>i=>{if(void 0===i)return e(...n);if(i.kind===S.unmanaged)throw new M(I.injectionDecoratorConflict,"Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found");return t(i,...n)}}function D(e){if(e.kind!==b.unknown&&!0!==e.isFromTypescriptParamType)throw new M(I.injectionDecoratorConflict,"Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found")}!function(e){e[e.multipleInjection=0]="multipleInjection",e[e.singleInjection=1]="singleInjection",e[e.unmanaged=2]="unmanaged"}(S||(S={}));const V=$(function(e,t,n){return e===S.multipleInjection?{chained:n?.chained??!1,kind:e,name:void 0,optional:!1,tags:new Map,value:t}:{kind:e,name:void 0,optional:!1,tags:new Map,value:t}},function(e,t,n,i){return D(e),t===S.multipleInjection?{...e,chained:i?.chained??!1,kind:t,value:n}:{...e,kind:t,value:n}});function O(e,t){return n=>{const i=n.properties.get(t);return n.properties.set(t,e(i)),n}}var E;function _(e,t,n,i){if(M.isErrorOfKind(i,I.injectionDecoratorConflict)){const o=function(e,t,n){if(void 0===n){if(void 0===t)throw new M(I.unknown,"Unexpected undefined property and index values");return{kind:E.property,property:t,targetClass:e.constructor}}return"number"==typeof n?{index:n,kind:E.parameter,targetClass:e}:{kind:E.method,method:t,targetClass:e}}(e,t,n);throw new M(I.injectionDecoratorConflict,`Unexpected injection error.\n\nCause:\n\n${i.message}\n\nDetails\n\n${function(e){switch(e.kind){case E.method:return`[class: "${e.targetClass.name}", method: "${e.method.toString()}"]`;case E.parameter:return`[class: "${e.targetClass.name}", index: "${e.index.toString()}"]`;case E.property:return`[class: "${e.targetClass.name}", property: "${e.property.toString()}"]`}}(o)}`,{cause:i})}throw i}function z(e,t){return(i,o,r)=>{try{void 0===r?function(e,t){const i=L(e,t);return(e,t)=>{n(e.constructor,h,g,O(i(e),t))}}(e,t)(i,o):"number"==typeof r?function(e,t){const i=L(e,t);return(e,t,o)=>{if(!function(e,t){return"function"==typeof e&&void 0===t}(e,t))throw new M(I.injectionDecoratorConflict,`Found an @inject decorator in a non constructor parameter.\nFound @inject decorator at method "${t?.toString()??""}" at class "${e.constructor.name}"`);n(e,h,g,function(e,t){return n=>{const i=n.constructorArguments[t];return n.constructorArguments[t]=e(i),n}}(i(e),o))}}(e,t)(i,o,r):function(e,t){const i=L(e,t);return(e,t,o)=>{if(!function(e){return void 0!==e.set}(o))throw new M(I.injectionDecoratorConflict,`Found an @inject decorator in a non setter property method.\nFound @inject decorator at method "${t.toString()}" at class "${e.constructor.name}"`);n(e.constructor,h,g,O(i(e),t))}}(e,t)(i,o,r)}catch(e){_(i,o,r,e)}}}function L(e,t){return n=>{const i=t(n);return t=>(i(t),e(t))}}function U(e){return z(V(S.singleInjection,e),k)}!function(e){e[e.method=0]="method",e[e.parameter=1]="parameter",e[e.property=2]="property"}(E||(E={}));const K="@inversifyjs/core/classIsInjectableFlagReflectKey";const q=[Array,BigInt,Boolean,Function,Number,Object,String];function G(t){const i=e(t,"design:paramtypes");void 0!==i&&n(t,h,g,function(e){return t=>(e.forEach((e,n)=>{var i;void 0!==t.constructorArguments[n]||(i=e,q.includes(i))||(t.constructorArguments[n]=function(e){return{isFromTypescriptParamType:!0,kind:S.singleInjection,name:void 0,optional:!1,tags:new Map,value:e}}(e))}),t)}(i))}function W(i){return o=>{!function(n){if(void 0!==e(n,K))throw new M(I.injectionDecoratorConflict,`Cannot apply @injectable decorator multiple times at class "${n.name}"`);t(n,K,!0)}(o),G(o),void 0!==i&&n(o,h,g,e=>({...e,scope:i}))}}function X(e,t,n){let i;return e.extendConstructorArguments??!0?(i=[...t.constructorArguments],n.constructorArguments.map((e,t)=>{i[t]=e})):i=n.constructorArguments,i}function H(e,t,n){return e?new Set([...t,...n]):n}function J(e,t,n){const i=e.lifecycle?.extendPostConstructMethods??!0,o=H(e.lifecycle?.extendPreDestroyMethods??!0,t.lifecycle.preDestroyMethodNames,n.lifecycle.preDestroyMethodNames);return{postConstructMethodNames:H(i,t.lifecycle.postConstructMethodNames,n.lifecycle.postConstructMethodNames),preDestroyMethodNames:o}}function Q(e,t,n){let i;return i=e.extendProperties??!0?new Map(l(t.properties,n.properties)):n.properties,i}function Y(e){return t=>{const i=N(e.type);n(t,h,g,function(e,t){const n=n=>({constructorArguments:X(e,t,n),lifecycle:J(e,t,n),properties:Q(e,t,n),scope:n.scope});return n}(e,i))}}function Z(e){return t=>{const n=i(t);if(void 0===n)throw new M(I.injectionDecoratorConflict,`Expected base type for type "${t.name}", none found.`);Y({...e,type:n})(t)}}function ee(e){return t=>{const n=[];let o=i(t);for(;void 0!==o&&o!==Object;){const e=o;n.push(e),o=i(e)}n.reverse();for(const i of n)Y({...e,type:i})(t)}}function te(e,t){return z(V(S.multipleInjection,e,t),k)}function ne(e){return t=>{void 0===t&&n(e,m,F,e=>e+1)}}function ie(e){return t=>{const n=t??{kind:b.unknown,name:void 0,optional:!1,tags:new Map};if(n.kind===S.unmanaged)throw new M(I.injectionDecoratorConflict,"Unexpected injection found. Found @unmanaged injection with additional @named, @optional, @tagged or @targetName injections");return e(n)}}function oe(e){const t=ie(function(e){return t=>{if(void 0!==t.name)throw new M(I.injectionDecoratorConflict,"Unexpected duplicated named decorator");return t.name=e,t}}(e));return z(t,ne)}function re(e){if(e.optional)throw new M(I.injectionDecoratorConflict,"Unexpected duplicated optional decorator");return e.optional=!0,e}function se(){return z(ie(re),ne)}function ae(){return(e,t,i)=>{try{n(e.constructor,h,g,(o=t,e=>{if(e.lifecycle.postConstructMethodNames.has(o))throw new M(I.injectionDecoratorConflict,`Unexpected duplicated postConstruct method ${o.toString()}`);return e.lifecycle.postConstructMethodNames.add(o),e}))}catch(n){_(e,t,void 0,n)}var o}}function ce(){return(e,t,i)=>{try{n(e.constructor,h,g,(o=t,e=>{if(e.lifecycle.preDestroyMethodNames.has(o))throw new M(I.injectionDecoratorConflict,`Unexpected duplicated preDestroy method ${o.toString()}`);return e.lifecycle.preDestroyMethodNames.add(o),e}))}catch(n){_(e,t,void 0,n)}var o}}function de(e,t){const n=ie(function(e,t){return n=>{if(n.tags.has(e))throw new M(I.injectionDecoratorConflict,"Unexpected duplicated tag decorator with existing tag");return n.tags.set(e,t),n}}(e,t));return z(n,ne)}function ue(){return{kind:S.unmanaged}}const le=$(ue,function(e){if(D(e),function(e){return void 0!==e.name||e.optional||e.tags.size>0}(e))throw new M(I.injectionDecoratorConflict,"Unexpected injection found. Found @unmanaged injection with additional @named, @optional, @tagged or @targetName injections");return ue()});function pe(){return z(le(),k)}var fe;function ve(e){if(!(e instanceof Error))return!1;return e instanceof RangeError&&/stack space|call stack|too much recursion/i.test(e.message)||"InternalError"===e.name&&/too much recursion/.test(e.message)}function he(e,t){if(ve(t)){const n=function(e){const t=[...e];if(0===t.length)return"(No dependency trace)";return t.map(o).join(" -> ")}(function(e){const t=new Set;for(const n of e.servicesBranch){if(t.has(n))return[...t,n];t.add(n)}return[...t]}(e));throw new M(I.planning,`Circular dependency found: ${n}`,{cause:t})}throw t}!function(e){e[e.multipleInjection=0]="multipleInjection",e[e.singleInjection=1]="singleInjection"}(fe||(fe={}));const ge=Symbol.for("@inversifyjs/core/LazyPlanServiceNode");class me{[ge];_serviceIdentifier;_serviceNode;constructor(e,t){this[ge]=!0,this._serviceNode=e,this._serviceIdentifier=t}get bindings(){return this._getNode().bindings}get isContextFree(){return this._getNode().isContextFree}get serviceIdentifier(){return this._serviceIdentifier}set bindings(e){this._getNode().bindings=e}set isContextFree(e){this._getNode().isContextFree=e}static is(e){return"object"==typeof e&&null!==e&&!0===e[ge]}invalidate(){this._serviceNode=void 0}isExpanded(){return void 0!==this._serviceNode}_getNode(){return void 0===this._serviceNode&&(this._serviceNode=this._buildPlanServiceNode()),this._serviceNode}}class ye{#M;constructor(e){this.#M=e}get name(){return this.#M.elem.name}get serviceIdentifier(){return this.#M.elem.serviceIdentifier}get tags(){return this.#M.elem.tags}getAncestor(){if(this.#M.elem.getAncestorsCalled=!0,void 0!==this.#M.previous)return new ye(this.#M.previous)}}function Me(e,t,n){const i=n?.customServiceIdentifier??t.serviceIdentifier,o=(!0===n?.chained?[...e.operations.getBindingsChained(i)]:[...e.operations.getBindings(i)??[]]).filter(e=>e.isSatisfiedBy(t));if(0===o.length&&void 0!==e.autobindOptions&&"function"==typeof i){const n=P(e.autobindOptions,i);e.operations.setBinding(n),n.isSatisfiedBy(t)&&o.push(n)}return o}class Ie{last;constructor(e){this.last=e}concat(e){return new Ie({elem:e,previous:this.last})}[Symbol.iterator](){let e=this.last;return{next:()=>{if(void 0===e)return{done:!0,value:void 0};const t=e.elem;return e=e.previous,{done:!1,value:t}}}}}function be(e){const t=new Map;return void 0!==e.rootConstraints.tag&&t.set(e.rootConstraints.tag.key,e.rootConstraints.tag.value),new Ie({elem:{getAncestorsCalled:!1,name:e.rootConstraints.name,serviceIdentifier:e.rootConstraints.serviceIdentifier,tags:t},previous:void 0})}function we(e){return void 0!==e.redirections}function Ce(e,t,n,i){const r=n.elem.serviceIdentifier,s=n.previous?.elem.serviceIdentifier;Array.isArray(e)?function(e,t,n,i,r,s){if(0!==e.length){const t=s[s.length-1]??n,a=`Ambiguous bindings found for service: "${o(t)}".${Ae(s)}\n\nRegistered bindings:\n\n${e.map(e=>function(e){switch(e.type){case u.Instance:return`[ type: "${e.type}", serviceIdentifier: "${o(e.serviceIdentifier)}", scope: "${e.scope}", implementationType: "${e.implementationType.name}" ]`;case u.ServiceRedirection:return`[ type: "${e.type}", serviceIdentifier: "${o(e.serviceIdentifier)}", redirection: "${o(e.targetServiceIdentifier)}" ]`;default:return`[ type: "${e.type}", serviceIdentifier: "${o(e.serviceIdentifier)}", scope: "${e.scope}" ]`}}(e.binding)).join("\n")}\n\nTrying to resolve bindings for "${Ne(n,i)}".${Pe(r)}`;throw new M(I.planning,a)}t||Se(n,i,r,s)}(e,t,r,s,n.elem,i):function(e,t,n,i,o,r){void 0!==e||t||Se(n,i,o,r)}(e,t,r,s,n.elem,i)}function Se(e,t,n,i){const r=i[i.length-1]??e,s=`No bindings found for service: "${o(r)}".\n\nTrying to resolve bindings for "${Ne(e,t)}".${Ae(i)}${Pe(n)}`;throw new M(I.planning,s)}function Ne(e,t){return void 0===t?`${o(e)} (Root service)`:o(t)}function Pe(e){const t=0===e.tags.size?"":`\n- tags:\n  - ${[...e.tags.keys()].map(e=>e.toString()).join("\n  - ")}`;return`\n\nBinding constraints:\n- service identifier: ${o(e.serviceIdentifier)}\n- name: ${e.name?.toString()??"-"}${t}`}function Ae(e){return 0===e.length?"":`\n\n- service redirections:\n  - ${e.map(e=>o(e)).join("\n  - ")}`}function Re(e,t,n,i){if(1===e.redirections.length){const[o]=e.redirections;return void(we(o)&&Re(o,t,n,[...i,o.binding.targetServiceIdentifier]))}Ce(e.redirections,t,n,i)}function xe(e,t,n){if(Array.isArray(e.bindings)&&1===e.bindings.length){const[i]=e.bindings;return void(we(i)&&Re(i,t,n,[i.binding.targetServiceIdentifier]))}Ce(e.bindings,t,n,[])}function Te(e){return r.is(e)?e.unwrap():e}function je(e){return(t,n,i)=>{const o=Te(i.value),r=n.concat({getAncestorsCalled:!1,name:i.name,serviceIdentifier:o,tags:i.tags}),s=new ye(r.last),a=i.kind===S.multipleInjection&&i.chained,c=Me(t,s,{chained:a}),d=[],u={bindings:d,isContextFree:!0,serviceIdentifier:o};if(d.push(...e(t,r,c,u,a)),u.isContextFree=!r.last.elem.getAncestorsCalled,i.kind===S.singleInjection){xe(u,i.optional,r.last);const[e]=d;u.bindings=e}return u}}function Be(e){return(t,n,i)=>{const o=Te(i.value),r=n.concat({getAncestorsCalled:!1,name:i.name,serviceIdentifier:o,tags:i.tags}),s=new ye(r.last),a=i.kind===fe.multipleInjection&&i.chained,c=Me(t,s,{chained:a}),d=[],u={bindings:d,isContextFree:!0,serviceIdentifier:o};if(d.push(...e(t,r,c,u,a)),u.isContextFree=!r.last.elem.getAncestorsCalled,i.kind===fe.singleInjection){xe(u,i.optional,r.last);const[e]=d;u.bindings=e}return u}}function Fe(e){const t=function(e){return(t,n,i)=>{const o={binding:n,classMetadata:t.operations.getClassMetadata(n.implementationType),constructorParams:[],propertyParams:new Map},r={autobindOptions:t.autobindOptions,node:o,operations:t.operations,servicesBranch:t.servicesBranch};return e(r,i)}}(e),n=function(e){return(t,n,i)=>{const o={binding:n,params:[]},r={autobindOptions:t.autobindOptions,node:o,operations:t.operations,servicesBranch:t.servicesBranch};return e(r,i)}}(e),i=(e,i,r,s,a)=>{const c=we(s)?s.binding.targetServiceIdentifier:s.serviceIdentifier;e.servicesBranch.push(c);const d=[];for(const s of r)switch(s.type){case u.Instance:d.push(t(e,s,i));break;case u.ResolvedValue:d.push(n(e,s,i));break;case u.ServiceRedirection:{const t=o(e,i,s,a);d.push(t);break}default:d.push({binding:s})}return e.servicesBranch.pop(),d},o=function(e){return(t,n,i,o)=>{const r={binding:i,redirections:[]},s=Me(t,new ye(n.last),{chained:o,customServiceIdentifier:i.targetServiceIdentifier});return r.redirections.push(...e(t,n,s,r,o)),r}}(i);return i}function ke(e,t,n,i){if(void 0!==e&&(me.is(n)&&!n.isExpanded()||n.isContextFree)){const i={tree:{root:n}};t.setPlan(e,i)}else t.setNonCachedServiceNode(n,i)}class $e extends me{#I;#b;#w;#C;constructor(e,t,n,i,o){super(o,Te(i.value)),this.#b=t,this.#I=e,this.#w=n,this.#C=i}_buildPlanServiceNode(){return this.#b(this.#I,this.#w,this.#C)}}class De extends me{#I;#S;#w;#N;constructor(e,t,n,i,o){super(o,Te(i.value)),this.#I=e,this.#S=t,this.#w=n,this.#N=i}_buildPlanServiceNode(){return this.#S(this.#I,this.#w,this.#N)}}function Ve(e,t,n,i){const o=function(e,t){const n=function(e,t){return(n,i,o)=>{if(o.kind===S.unmanaged)return;const s=function(e){let t;if(0===e.tags.size)t=void 0;else{if(1!==e.tags.size)return;{const[n,i]=e.tags.entries().next().value;t={key:n,value:i}}}const n=r.is(e.value)?e.value.unwrap():e.value;return e.kind===S.multipleInjection?{chained:e.chained,isMultiple:!0,name:e.name,optional:e.optional,serviceIdentifier:n,tag:t}:{isMultiple:!1,name:e.name,optional:e.optional,serviceIdentifier:n,tag:t}}(o);if(void 0!==s){const e=n.operations.getPlan(s);if(void 0!==e&&e.tree.root.isContextFree)return e.tree.root}const a=t(n,i,o),c=new $e(n,e,i,o,a);return ke(s,n.operations,c,{bindingConstraintsList:i,chainedBindings:o.kind===S.multipleInjection&&o.chained,optionalBindings:o.optional}),c}}(e,t);return(e,t,i)=>{const o=t.classMetadata;for(const[r,s]of o.constructorArguments.entries())t.constructorParams[r]=n(e,i,s);for(const[r,s]of o.properties){const o=n(e,i,s);void 0!==o&&t.propertyParams.set(r,o)}return e.node}}(e,n),s=function(e,t){const n=function(e,t){return(n,i,o)=>{const s=function(e){let t;if(0===e.tags.size)t=void 0;else{if(1!==e.tags.size)return;{const[n,i]=e.tags.entries().next().value;t={key:n,value:i}}}const n=r.is(e.value)?e.value.unwrap():e.value;return e.kind===fe.multipleInjection?{chained:e.chained,isMultiple:!0,name:e.name,optional:e.optional,serviceIdentifier:n,tag:t}:{isMultiple:!1,name:e.name,optional:e.optional,serviceIdentifier:n,tag:t}}(o);if(void 0!==s){const e=n.operations.getPlan(s);if(void 0!==e&&e.tree.root.isContextFree)return e.tree.root}const a=t(n,i,o),c=new De(n,e,i,o,a);return ke(s,n.operations,c,{bindingConstraintsList:i,chainedBindings:o.kind===fe.multipleInjection&&o.chained,optionalBindings:o.optional}),c}}(e,t);return(e,t,i)=>{const o=t.binding.metadata;for(const[r,s]of o.arguments.entries())t.params[r]=n(e,i,s);return e.node}}(t,i);return(e,t)=>e.node.binding.type===u.Instance?o(e,e.node,t):s(e,e.node,t)}class Oe extends me{#I;constructor(e,t){super(t,t.serviceIdentifier),this.#I=e}_buildPlanServiceNode(){return Ue(this.#I)}}const Ee=je(Le),_e=Be(Le),ze=Fe(Ve(Ee,_e,Ee,_e));function Le(e,t,n,i,o){return ze(e,t,n,i,o)}const Ue=function(e){return t=>{const n=be(t),i=new ye(n.last),o=t.rootConstraints.isMultiple&&t.rootConstraints.chained,r=Me(t,i,{chained:o}),s=[],a={bindings:s,isContextFree:!0,serviceIdentifier:t.rootConstraints.serviceIdentifier};if(s.push(...e(t,n,r,a,o)),a.isContextFree=!n.last.elem.getAncestorsCalled,!t.rootConstraints.isMultiple){xe(a,t.rootConstraints.isOptional??!1,n.last);const[e]=s;a.bindings=e}return a}}(ze);function Ke(e){try{const t=function(e){return e.rootConstraints.isMultiple?{chained:e.rootConstraints.chained,isMultiple:!0,name:e.rootConstraints.name,optional:e.rootConstraints.isOptional??!1,serviceIdentifier:e.rootConstraints.serviceIdentifier,tag:e.rootConstraints.tag}:{isMultiple:!1,name:e.rootConstraints.name,optional:e.rootConstraints.isOptional??!1,serviceIdentifier:e.rootConstraints.serviceIdentifier,tag:e.rootConstraints.tag}}(e),n=e.operations.getPlan(t);if(void 0!==n)return n;const i=Ue(e),o={tree:{root:new Oe(e,i)}};return e.operations.setPlan(t,o),o}catch(t){he(e,t)}}var qe;!function(e){e.bindingAdded="bindingAdded",e.bindingRemoved="bindingRemoved"}(qe||(qe={}));class Ge{#P;#A;#R;constructor(){this.#P=[],this.#A=8,this.#R=1024}*[Symbol.iterator](){let e=0;for(const t of this.#P){const n=t.deref();void 0===n?++e:yield n}this.#P.length>=this.#A&&this.#x(e)&&this.#T(e)}push(e){const t=new WeakRef(e);if(this.#P.push(t),this.#P.length>=this.#A&&this.#P.length%this.#R===0){let e=0;for(const t of this.#P)void 0===t.deref()&&++e;this.#x(e)&&this.#T(e)}}#T(e){const t=new Array(this.#P.length-e);let n=0;for(const e of this.#P)e.deref()&&(t[n++]=e);this.#P=t}#x(e){return e>=.5*this.#P.length}}const We=Fe(Ve(Ee,_e,function(e,t,n){return Xe(e,t,n)},function(e,t,n){return He(e,t,n)})),Xe=function(e){const t=je(e);return(e,n,i)=>{try{return t(e,n,i)}catch(e){if(M.isErrorOfKind(e,I.planning))return;throw e}}}(We),He=function(e){const t=Be(e);return(e,n,i)=>{try{return t(e,n,i)}catch(e){if(M.isErrorOfKind(e,I.planning))return;throw e}}}(We);function Je(e,t,n,i,o){if(me.is(t)&&!t.isExpanded())return{isContextFreeBinding:!0,shouldInvalidateServiceNode:!1};const r=new ye(i.last);return!n.isSatisfiedBy(r)||i.last.elem.getAncestorsCalled?{isContextFreeBinding:!i.last.elem.getAncestorsCalled,shouldInvalidateServiceNode:!1}:function(e,t,n,i,o){let r;try{[r]=We(e,i,[n],t,o)}catch(e){if(ve(e))return{isContextFreeBinding:!1,shouldInvalidateServiceNode:!0};throw e}return function(e,t){if(Array.isArray(e.bindings))e.bindings.push(t);else{if(void 0!==e.bindings){if(!me.is(e))throw new M(I.planning,"Unexpected non-lazy plan service node. This is likely a bug in the planning logic. Please, report this issue");return{isContextFreeBinding:!0,shouldInvalidateServiceNode:!0}}e.bindings=t}return{isContextFreeBinding:!0,shouldInvalidateServiceNode:!1}}(t,r)}(e,t,n,i,o)}function Qe(e,t,n,i){if(me.is(e)&&!e.isExpanded())return{bindingNodeRemoved:void 0,isContextFreeBinding:!0};const o=new ye(n.last);if(!t.isSatisfiedBy(o)||n.last.elem.getAncestorsCalled)return{bindingNodeRemoved:void 0,isContextFreeBinding:!n.last.elem.getAncestorsCalled};let r;if(Array.isArray(e.bindings))e.bindings=e.bindings.filter(e=>e.binding!==t||(r=e,!1));else if(e.bindings?.binding===t)if(r=e.bindings,i)e.bindings=void 0;else{if(!me.is(e))throw new M(I.planning,"Unexpected non-lazy plan service node. This is likely a bug in the planning logic. Please, report this issue");e.invalidate()}return{bindingNodeRemoved:r,isContextFreeBinding:!0}}class Ye{#j;#B;#F;#k;#$;#D;constructor(){this.#j=new Map,this.#B=this.#V(),this.#F=this.#V(),this.#k=this.#V(),this.#$=this.#V(),this.#D=new Ge}clearCache(){for(const e of this.#O())e.clear();for(const e of this.#D)e.clearCache()}get(e){return void 0===e.name?void 0===e.tag?this.#E(this.#B,e).get(e.serviceIdentifier):this.#E(this.#$,e).get(e.serviceIdentifier)?.get(e.tag.key)?.get(e.tag.value):void 0===e.tag?this.#E(this.#F,e).get(e.serviceIdentifier)?.get(e.name):this.#E(this.#k,e).get(e.serviceIdentifier)?.get(e.name)?.get(e.tag.key)?.get(e.tag.value)}invalidateServiceBinding(e){this.#_(e),this.#z(e),this.#L(e),this.#U(e),this.#K(e);for(const t of this.#D)t.invalidateServiceBinding(e)}set(e,t){void 0===e.name?void 0===e.tag?this.#E(this.#B,e).set(e.serviceIdentifier,t):this.#q(this.#q(this.#E(this.#$,e),e.serviceIdentifier),e.tag.key).set(e.tag.value,t):void 0===e.tag?this.#q(this.#E(this.#F,e),e.serviceIdentifier).set(e.name,t):this.#q(this.#q(this.#q(this.#E(this.#k,e),e.serviceIdentifier),e.name),e.tag.key).set(e.tag.value,t)}setNonCachedServiceNode(e,t){let n=this.#j.get(e.serviceIdentifier);void 0===n&&(n=new Map,this.#j.set(e.serviceIdentifier,n)),n.set(e,t)}subscribe(e){this.#D.push(e)}#V(){const e=new Array(8);for(let t=0;t<e.length;++t)e[t]=new Map;return e}#G(e,t,n,i){const o=!!(2&t);let r;if(o){r={chained:!!(0&t),isMultiple:o,serviceIdentifier:e.binding.serviceIdentifier}}else r={isMultiple:o,serviceIdentifier:e.binding.serviceIdentifier};return!!(1&t)&&(r.isOptional=!0),void 0!==n&&(r.name=n),void 0!==i&&(r.tag=i),{autobindOptions:void 0,operations:e.operations,rootConstraints:r,servicesBranch:[]}}#q(e,t){let n=e.get(t);return void 0===n&&(n=new Map,e.set(t,n)),n}#E(e,t){return e[this.#W(t)]}#O(){return[this.#j,...this.#B,...this.#F,...this.#k,...this.#$]}#W(e){return e.isMultiple?(e.chained?4:0)|(e.optional?1:0)|2:e.optional?1:0}#z(e){for(const[t,n]of this.#F.entries()){const i=n.get(e.binding.serviceIdentifier);if(void 0!==i)for(const[n,o]of i.entries())this.#X(e,o,t,n,void 0)}}#L(e){for(const[t,n]of this.#k.entries()){const i=n.get(e.binding.serviceIdentifier);if(void 0!==i)for(const[n,o]of i.entries())for(const[i,r]of o.entries())for(const[o,s]of r.entries())this.#X(e,s,t,n,{key:i,value:o})}}#H(e){switch(e.binding.type){case u.ServiceRedirection:for(const t of e.redirections)this.#H(t);break;case u.Instance:for(const t of e.constructorParams)void 0!==t&&this.#J(t);for(const t of e.propertyParams.values())this.#J(t);break;case u.ResolvedValue:for(const t of e.params)this.#J(t)}}#J(e){const t=this.#j.get(e.serviceIdentifier);void 0!==t&&t.has(e)&&(t.delete(e),this.#Q(e))}#Q(e){if((!me.is(e)||e.isExpanded())&&void 0!==e.bindings)if(Array.isArray(e.bindings))for(const t of e.bindings)this.#H(t);else this.#H(e.bindings)}#K(e){const t=this.#j.get(e.binding.serviceIdentifier);if(void 0!==t)switch(e.kind){case qe.bindingAdded:for(const[n,i]of t){const t=Je({autobindOptions:void 0,operations:e.operations,servicesBranch:[]},n,e.binding,i.bindingConstraintsList,i.chainedBindings);t.isContextFreeBinding?t.shouldInvalidateServiceNode&&me.is(n)&&(this.#Q(n),n.invalidate()):this.clearCache()}break;case qe.bindingRemoved:for(const[n,i]of t){const t=Qe(n,e.binding,i.bindingConstraintsList,i.optionalBindings);t.isContextFreeBinding?void 0!==t.bindingNodeRemoved&&this.#H(t.bindingNodeRemoved):this.clearCache()}}}#_(e){for(const[t,n]of this.#B.entries()){const i=n.get(e.binding.serviceIdentifier);this.#X(e,i,t,void 0,void 0)}}#U(e){for(const[t,n]of this.#$.entries()){const i=n.get(e.binding.serviceIdentifier);if(void 0!==i)for(const[n,o]of i.entries())for(const[i,r]of o.entries())this.#X(e,r,t,void 0,{key:n,value:i})}}#X(e,t,n,i,o){if(void 0!==t&&me.is(t.tree.root)){const c=this.#G(e,n,i,o);switch(e.kind){case qe.bindingAdded:{const n=(r=c,s=t.tree.root,a=e.binding,me.is(s)&&!s.isExpanded()?{isContextFreeBinding:!0,shouldInvalidateServiceNode:!1}:Je(r,s,a,be(r),r.rootConstraints.isMultiple&&r.rootConstraints.chained));n.isContextFreeBinding?n.shouldInvalidateServiceNode&&(this.#Q(t.tree.root),t.tree.root.invalidate()):this.clearCache()}break;case qe.bindingRemoved:{const n=function(e,t,n){return me.is(t)&&!t.isExpanded()?{bindingNodeRemoved:void 0,isContextFreeBinding:!0}:Qe(t,n,be(e),e.rootConstraints.isOptional??!1)}(c,t.tree.root,e.binding);n.isContextFreeBinding?void 0!==n.bindingNodeRemoved&&this.#H(n.bindingNodeRemoved):this.clearCache()}}}var r,s,a}}function Ze(e,t){if(ve(t)){const n=function(e){const t=[...e];if(0===t.length)return"(No dependency trace)";return t.map(o).join(" -> ")}(function(e){const t=e.planResult.tree.root,n=[];function i(e){const t=n.indexOf(e);if(-1!==t){return[...n.slice(t),e].map(e=>e.serviceIdentifier)}n.push(e);try{for(const t of function(e){const t=[],n=e.bindings;if(void 0===n)return t;const i=e=>{if(we(e))for(const t of e.redirections)i(t);else switch(e.binding.type){case u.Instance:{const n=e;for(const e of n.constructorParams)void 0!==e&&t.push(e);for(const e of n.propertyParams.values())t.push(e);break}case u.ResolvedValue:{const n=e;for(const e of n.params)t.push(e);break}}};if(Array.isArray(n))for(const e of n)i(e);else i(n);return t}(e)){const e=i(t);if(void 0!==e)return e}}finally{n.pop()}}return i(t)??[]}(e));throw new M(I.planning,`Circular dependency found: ${n}`,{cause:t})}throw t}function et(e,t){return s(t)?(e.cache={isRight:!0,value:t},t.then(t=>tt(e,t))):tt(e,t)}function tt(e,t){return e.cache={isRight:!0,value:t},t}function nt(e,t,n){const i=e.getActivations(t);return void 0===i?n:s(n)?it(e,n,i[Symbol.iterator]()):function(e,t,n){let i=t,o=n.next();for(;!0!==o.done;){const t=o.value(e.context,i);if(s(t))return it(e,t,n);i=t,o=n.next()}return i}(e,n,i[Symbol.iterator]())}async function it(e,t,n){let i=await t,o=n.next();for(;!0!==o.done;)i=await o.value(e.context,i),o=n.next();return i}function ot(e,t,n){let i=n;if(void 0!==t.onActivation){const n=t.onActivation;i=s(i)?i.then(t=>n(e.context,t)):n(e.context,i)}return nt(e,t.serviceIdentifier,i)}function rt(e){return(t,n)=>{if(n.cache.isRight)return n.cache.value;return et(n,ot(t,n,e(t,n)))}}const st=rt(function(e,t){return t.value});function at(e){return e}function ct(e,t){return(n,i)=>{const o=e(i);switch(o.scope){case d.Singleton:if(o.cache.isRight)return o.cache.value;return et(o,ot(n,o,t(n,i)));case d.Request:{if(n.requestScopeCache.has(o.id))return n.requestScopeCache.get(o.id);const e=ot(n,o,t(n,i));return n.requestScopeCache.set(o.id,e),e}case d.Transient:return ot(n,o,t(n,i))}}}const dt=(e=>ct(at,e))(function(e,t){return t.value(e.context)});const ut=rt(function(e,t){return t.factory(e.context)});function lt(e,t,n){const i=function(e,t,n){if(!(n in e))throw new M(I.resolution,`Expecting a "${n.toString()}" property when resolving "${t.implementationType.name}" class @postConstruct decorated method, none found.`);if("function"!=typeof e[n])throw new M(I.resolution,`Expecting a "${n.toString()}" method when resolving "${t.implementationType.name}" class @postConstruct decorated method, a non function property was found instead.`);{let i;try{i=e[n]()}catch(e){throw new M(I.resolution,`Unexpected error found when calling "${n.toString()}" @postConstruct decorated method on class "${t.implementationType.name}"`,{cause:e})}if(s(i))return async function(e,t,n){try{await n}catch(n){throw new M(I.resolution,`Unexpected error found when calling "${t.toString()}" @postConstruct decorated method on class "${e.implementationType.name}"`,{cause:n})}}(t,n,i)}}(e,t,n);return s(i)?i.then(()=>e):e}function pt(e,t,n){if(0===n.size)return e;let i=e;for(const e of n)i=s(i)?i.then(n=>lt(n,t,e)):lt(i,t,e);return i}function ft(e){return(t,n,i)=>{const o=new i.binding.implementationType(...t),r=e(n,o,i);return s(r)?r.then(()=>pt(o,i.binding,i.classMetadata.lifecycle.postConstructMethodNames)):pt(o,i.binding,i.classMetadata.lifecycle.postConstructMethodNames)}}const vt=rt(function(e,t){return t.provider(e.context)});function ht(e){return e.binding}function gt(e){return e.binding}const mt=function(e){return(t,n,i)=>{const o=[];for(const[r,a]of i.propertyParams){const c=i.classMetadata.properties.get(r);if(void 0===c)throw new M(I.resolution,`Expecting metadata at property "${r.toString()}", none found`);c.kind!==S.unmanaged&&void 0!==a.bindings&&(n[r]=e(t,a),s(n[r])&&o.push((async()=>{n[r]=await n[r]})()))}if(o.length>0)return Promise.all(o).then(()=>{})}}(Nt),yt=function(e){return function t(n,i){const o=[];for(const r of i.redirections)we(r)?o.push(...t(n,r)):o.push(e(n,r));return o}}(St),Mt=function(e,t,n){return(i,o)=>{const r=e(i,o);return s(r)?t(r,i,o):n(r,i,o)}}(function(e){return(t,n)=>{const i=[];for(const o of n.constructorParams)void 0===o?i.push(void 0):i.push(e(t,o));return i.some(s)?Promise.all(i):i}}(Nt),function(e){return async(t,n,i)=>{const o=await t;return e(o,n,i)}}(ft(mt)),ft(mt)),It=function(e){return(t,n)=>{const i=e(t,n);return s(i)?i.then(e=>n.binding.factory(...e)):n.binding.factory(...i)}}(function(e){return(t,n)=>{const i=[];for(const o of n.params)i.push(e(t,o));return i.some(s)?Promise.all(i):i}}(Nt)),bt=(e=>ct(ht,e))(Mt),wt=(e=>ct(gt,e))(It);function Ct(e){try{return Nt(e,e.planResult.tree.root)}catch(t){Ze(e,t)}}function St(e,t){switch(t.binding.type){case u.ConstantValue:return st(e,t.binding);case u.DynamicValue:return dt(e,t.binding);case u.Factory:return ut(e,t.binding);case u.Instance:return bt(e,t);case u.Provider:return vt(e,t.binding);case u.ResolvedValue:return wt(e,t)}}function Nt(e,t){if(void 0!==t.bindings)return Array.isArray(t.bindings)?function(e,t){const n=[];for(const i of t)we(i)?n.push(...yt(e,i)):n.push(St(e,i));if(n.some(s))return Promise.all(n);return n}(e,t.bindings):function(e,t){if(we(t)){const n=yt(e,t);if(1===n.length)return n[0];throw new M(I.resolution,"Unexpected multiple resolved values on single injection")}return St(e,t)}(e,t.bindings)}function Pt(e){return void 0!==e.scope}function At(e,t){if("function"==typeof e[t]){return e[t]()}}function Rt(e,t){const n=e.lifecycle.preDestroyMethodNames;if(0===n.size)return;let i;for(const e of n)i=void 0===i?At(t,e):i.then(()=>At(t,e));return i}function xt(e,t,n){const i=e.getDeactivations(t);if(void 0!==i)return s(n)?Tt(n,i[Symbol.iterator]()):function(e,t){let n=t.next();for(;!0!==n.done;){const i=n.value(e);if(s(i))return Tt(e,t);n=t.next()}}(n,i[Symbol.iterator]())}async function Tt(e,t){const n=await e;let i=t.next();for(;!0!==i.done;)await i.value(n),i=t.next()}function jt(e,t){const n=function(e,t){if(t.type===u.Instance){const n=e.getClassMetadata(t.implementationType),i=t.cache.value;return s(i)?i.then(e=>Rt(n,e)):Rt(n,i)}}(e,t);return void 0===n?Bt(e,t):n.then(()=>Bt(e,t))}function Bt(e,t){const n=t.cache;return s(n.value)?n.value.then(n=>Ft(e,t,n)):Ft(e,t,n.value)}function Ft(e,t,n){let i;if(void 0!==t.onDeactivation){i=(0,t.onDeactivation)(n)}return void 0===i?xt(e,t.serviceIdentifier,n):i.then(()=>xt(e,t.serviceIdentifier,n))}function kt(e,t){if(void 0===t)return;const n=function(e){const t=[];for(const n of e)Pt(n)&&n.scope===d.Singleton&&n.cache.isRight&&t.push(n);return t}(t),i=[];for(const t of n){const n=jt(e,t);void 0!==n&&i.push(n)}return i.length>0?Promise.all(i).then(()=>{}):void 0}function $t(e,t){const n=e.getBindingsFromModule(t);return kt(e,n)}function Dt(e,t){const n=e.getBindings(t);return kt(e,n)}export{v as ActivationsService,T as BindingService,qe as CacheBindingInvalidationKind,S as ClassElementMetadataKind,j as DeactivationsService,M as InversifyCoreError,I as InversifyCoreErrorKind,Ye as PlanResultCacheService,fe as ResolvedValueElementMetadataKind,d as bindingScopeValues,u as bindingTypeValues,B as decorate,c as getBindingId,N as getClassMetadata,U as inject,Z as injectFromBase,ee as injectFromHierarchy,W as injectable,te as multiInject,oe as named,se as optional,Ke as plan,ae as postConstruct,ce as preDestroy,Ct as resolve,kt as resolveBindingsDeactivations,$t as resolveModuleDeactivations,Dt as resolveServiceDeactivations,de as tagged,pe as unmanaged};
//# sourceMappingURL=index.js.map
